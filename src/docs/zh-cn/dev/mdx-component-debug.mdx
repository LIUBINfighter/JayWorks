---
title: "MDX 自定义组件渲染 Debug 记录"
description: "从 <SimpleButton /> 变成空 <div> 的根因、误区与最终修复方案"
date: "2025-09-26"
author: JayWorks
status: draft
---

# MDX 自定义组件渲染 Debug 记录

> 目的：沉淀这次调试过程中遇到的“组件标签被降级成 `<div>`”问题，便于后续扩展 MDX 渲染能力、避免再次踩坑。

## 背景

我们在 Obsidian 插件中使用：

```
remark-parse → remark-frontmatter → remark-mdx → remark-rehype → rehype-react
```

期望：在 MDX 文档中写 `<SimpleButton label="点我" />` 直接渲染成 React 组件。最初组件未显示，DOM 中出现一个空的 `<div>`。

## 现象 (Symptoms)

- `<SimpleButton />`、`<OcrPlayground />` 在最终 HTML 中变为 `<div></div>` 或空占位
- 没有前端报错（React 认为只是一个未知标签 → 被当普通 DOM 节点处理）
- 去掉 MDX 自定义标签后纯 Markdown 正常
- 尝试调整组件 registry 键名大小写无效 / 表现不一致

## 初始错误假设 (Wrong Hypotheses)

| 假设 | 原因 | 结果 |
| ---- | ---- | ---- |
| rehype-react 会自动把标签名小写化再查映射 | 观察到找不到组件 | 实测其直接按 tagName 查找；非根因 |
| 需要强制 lower-case 组件 map 键 | 试图匹配“simplebutton” | 导致真实 PascalCase 键无法命中 |
| React 版本或 jsx-runtime 配置问题 | 怀疑环境 | 与主题无关 |
| 需要保留自定义 `rehypeMdxToElements` 插件 | 原逻辑能用 | 核心确实在“需要转换”但更准确是 *哪一层* 处理 |

## 根因 (Root Cause)

`remark-rehype` 默认不认识 `mdxJsxFlowElement` / `mdxJsxTextElement` 这类 MDX 扩展节点。转换阶段信息丢失，被降级成通用占位（空 div）。随后 `rehype-react` 拿到的已是“失真” HAST，无法再映射回组件。

> 关键：不是 React 映射失败，而是 **AST 在 Markdown → HAST 的桥接层已经丢了结构语义**。

## 解决策略 (Strategy)

1. 保留 `remark-mdx` 产生的 MDX 节点。
2. 在 `remark-rehype` 配置里 `passThrough` 相关 MDX 节点类型，避免它“静默降级”。
3. 在 rehype 阶段（HAST）写一个 `rehypeMdxJsxToElement` 插件，将 `mdxJsx*` 节点显式转换为标准 `{ type: 'element', tagName, properties }`。
4. 组件白名单：同时提供 PascalCase 与 lowercase 键，减少大小写差异误判。
5. 为安全起见忽略表达式属性 / 函数（仅支持字符串、布尔字面量）。

## 关键修复代码 (Diff 摘要)

```ts
// unifiedMdx.tsx (片段)
.use(remarkRehype, { allowDangerousHtml: false, passThrough: [
  'mdxjsEsm', 'mdxJsxFlowElement', 'mdxJsxTextElement'
] })
.use(rehypeMdxJsxToElement) // 自定义插件：mdxJsx* → element
.use(rehypeReact, { jsx, jsxs, Fragment, components })
```

```ts
function rehypeMdxJsxToElement() {
  return (tree) => {
    visit(tree)
    function visit(node) {
      if (!node || typeof node !== 'object') return;
      if (Array.isArray(node.children)) node.children.forEach(visit);
      if (node.type === 'mdxJsxFlowElement' || node.type === 'mdxJsxTextElement') {
        const props = extractLiteralProps(node.attributes);
        node.type = 'element';
        node.tagName = node.name;
        node.properties = props;
      }
    }
  }
}
```

```ts
// registry.ts
export function getComponentMap() {
  return {
    SimpleButton,
    simplebutton: SimpleButton,
    OcrPlayground,
    ocrplayground: OcrPlayground,
  } as const;
}
```

## 属性支持范围 (Current Prop Support)

| 类型 | 支持 | 说明 |
| ---- | ---- | ---- |
| 字符串字面量 | ✅ | `label="点我"` |
| 布尔（无值属性） | ✅ | `<Comp enabled />` → `enabled=true` |
| 数字字面量 | ❌ | 目前作为字符串，需要手动解析 |
| 表达式 `{...}` | ❌ | 被忽略以保证安全 |
| 对象 / 数组字面量 | ❌ | 未解析 |
| 函数 / 事件处理 | ❌ | 使用 action 映射替代（计划） |

## 测试用例 (Manual Smoke)

1. 在 `demoMdx` 中添加：`<SimpleButton label="Test" />` → 渲染按钮 + 点击递增计数 ✔
2. 添加表达式属性：`<SimpleButton label={"X"} />` → label 退化为无（被忽略）✔（符合预期）
3. 添加未注册组件：`<UnknownBox />` → 渲染为空占位，不报错 ✔

## 仍需的后续工作 (Next Steps)

| 优先级 | 项目 | 说明 |
| ------ | ---- | ---- |
| 高 | action 映射 | `<SimpleButton action="notice" />` → 绑定安全回调 |
| 高 | 限制文档 | 单独列出支持/不支持的 MDX 语法 |
| 中 | Processor 缓存 | 频繁渲染时避免重复创建 unified pipeline |
| 中 | 数字/JSON 属性解析 | 允许 `count="123"` 自动转 number |
| 低 | 表达式白名单 DSL | 可选 mini 解析器支撑简单表达式 |

## 经验总结 (Lessons Learned)

- 统一管线里**最容易忽略的是“桥接层”**（remark → rehype）。一旦在这里信息丢失，后续所有渲染 / 映射都失效。
- 尽量把“危险/高成本”能力（表达式执行）后置，通过 action 字符串或上下文对象替代直接函数注入。
- 双键注册（PascalCase + lowercase）可以减少 early phase 的大小写争议，让调试聚焦在真正的语义转换问题。

## 快速检查清单 (Checklist)

| 项 | 状态 |
| --- | --- |
| 组件标签是否仍是 mdxJsx* 节点并在 rehype 阶段转换 | ✅ |
| 是否剥离 import/export (mdxjsEsm) | ✅ |
| 是否禁用危险 HTML | ✅ (`allowDangerousHtml: false`) |
| 是否限制属性为字面量 | ✅ |
| 是否有 fallback 键名策略 | ✅ |

## 附录：潜在替代方案对比

| 方案 | 优点 | 缺点 |
| ---- | ---- | ---- |
| 当前（手写转换插件） | 精准控制、安全、体积小 | 需维护少量代码 |
| 使用 mdx 全量运行时 (xdm / @mdx-js/runtime) | 表达力强 | 体积大 + 安全面复杂，不适合 Obsidian 内嵌 |
| 预编译 MDX → ESM (构建期) | 性能好 | 需要构建管线 & 动态内容不便 |

---

若后续扩展，请在此文档继续追加遇到的新问题与决策记录。
