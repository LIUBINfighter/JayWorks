---
title: "使用 unified + remark + rehype-react 在 Obsidian 插件中渲染交互式 MDX 文档"
description: "实现计划：为什么选 unified，如何集成，依赖与示例代码"
---

## 摘要

看起来就方案2啦！这是为我的内置文档系统（README:不应该离开工作区看文档，尤其是网络加载慢，和obsidian内部组件结构心智模型完全不同的文档网站）我后来要支持复杂的OCR模型使用教学，类似mermaid live editor/vue playground之类的复杂体验，看起来方案2最合适了

选择 `unified + remark + rehype-react` 作为解析与渲染管线的核心，理由：

- 在 AST 层面操作更可靠，可精确区分代码块、行内元素与自定义组件。
- 能把 Markdown 文本无缝转换为 React 元素树，从而把 Obsidian 的 Markdown 表现与 React 的交互能力结合到一起。
- 相比运行时 MDX 编译（如 `mdx-bundler`），unified 体积更小，安全性更高，更适合在 Obsidian 插件中运行。

下面提供一个详细的实现计划、依赖清单与示例代码片段，供快速上手。

## 目标

- 在 Obsidian 插件内解析用户笔记或内置文档的 Markdown/MDX 内容。
- 能在文档中嵌入交互式 React 组件（例如 `OcrPlayground`、`MermaidLive`、自定义控件等）。
- 正确处理 frontmatter、代码块与内联代码，避免误识别组件标签。
- 提供可扩展的组件注册/注入机制，让插件外的组件也可以被安全映射使用。

## 依赖（建议）

- unified
- remark-parse
- remark-frontmatter
- remark-mdx
- remark-rehype
- rehype-react
- (可选) gray-matter（若仍需在其他地方单独解析 frontmatter）

> 这些包都在 remark/rehype/unified 生态中，社区活跃，文档丰富。

## 实现步骤（高层）

1. 包依赖安装（在开发环境中）

   - 由于 Obsidian 插件需要打包，尽量把依赖限制在必要范围并在构建时把它们打包到 `main.js`。

2. 封装一个 MDX 渲染器工具（例如 `src/utils/unifiedMdx.tsx`）

   - 提供一个函数 `renderMdxToReact(mdxString: string, components: Record<string, React.ComponentType<any>>) => React.ReactElement`。
   - Pipeline：`unified().use(remarkParse).use(remarkMdx).use(remarkRehype).use(rehypeReact, {createElement: React.createElement, components})`

3. 在你的 `ItemView`/React 顶层组件里调用这个渲染器：

   - 加载文档（来自内置资源或 Vault）；
   - 调用 `renderMdxToReact` 并把返回的 React 元素渲染到 `createRoot`；
   - 组件注册表（components）由插件初始化时注入一个 map，包含 `OcrPlayground`、`SimpleButton` 等。

4. 状态与回调：

   - 顶层组件管理全局状态（例如 OCR 的输入/输出），并把 handler 通过 `components` 中的 prop 注入到交互组件中（rehype-react 会把 MDX 中的标签名映射到 components 中的 React 组件）。

5. 安全考虑：

   - 禁止或过滤 MDX 中的 `import`/`eval`（remark-mdx 会识别 import，但在运行时执行外部代码会带来风险）。
   - 对 components 映射只导出白名单组件，避免把任意内联代码变成可执行逻辑。

## 关键代码示例（TypeScript/React）

```ts
import React from 'react';
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkMdx from 'remark-mdx';
import remarkRehype from 'remark-rehype';
import rehypeReact from 'rehype-react';

export function renderMdxToReact(mdx: string, components: Record<string, any>) {
  const processor = unified()
    .use(remarkParse)
    .use(remarkMdx)
    .use(remarkRehype)
    .use(rehypeReact, {
      createElement: React.createElement,
      Fragment: React.Fragment,
      components,
    });

  // process 返回带 result 的 VFile（result 是 React element）
  // 注意：unified.processSync 可用于同步流程（小文本）
  const vfile = processor.processSync(mdx) as any;
  return vfile.result as React.ReactElement;
}
```

在 `ItemView` 的 React 组件中：

```tsx
// ... 在你的 React 组件里
const mdx = await this.app.vault.cachedRead(file);
const components = { SimpleButton, OcrPlayground, MermaidLive };
const reactElement = renderMdxToReact(mdx, components);
root.render(reactElement);
```

## 注意点与陷阱

- 性能：大型文档在首次解析时会有一些开销，建议对大型文档做懒加载或分页展示。
- 包体积：rehype/react 相关包会增加打包体积。你可以使用 esbuild 的 tree-shaking 与代码分割把影响限制到最小。
- import 支持：如果你允许 MDX 文档包含 import（并在运行时执行），你会面对巨大安全与体积代价，通常应禁止。
- 插件市场政策：确保你没有引入自动联网或执行用户代码的行为，以免审核被拒。

## 迁移与迭代建议

- 阶段 1（最小可行）：在插件中集成 `renderMdxToReact`，并把 `SimpleButton` 等少量白名单组件接入。验证在 Obsidian 内部的渲染和交互。
- 阶段 2（增强体验）：支持组件的 props 绑定到顶层状态（例如实时预览编辑器），完善错误边界与样式。
- 阶段 3（扩展）：引入更复杂的交互组件（如 Playground），并通过细粒度权限/沙箱策略保护执行环境。

---

如果你愿意，我可以直接替你实现第一个 PoC：
- 在 `src/utils/unifiedMdx.tsx` 创建 `renderMdxToReact` 工具；
- 在 `src/views/MyItemView.tsx` 用新的工具替换当前 tokenizer 实现；
- 把 `SimpleButton`、`OcrPlayground`（占位 stub）整合到组件注册表，做一个内置文档的交互示例。

要我现在开始实现 PoC 吗？
